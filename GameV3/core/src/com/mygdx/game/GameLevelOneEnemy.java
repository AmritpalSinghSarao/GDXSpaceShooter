package com.mygdx.game;


import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.graphics.g2d.Sprite;
import com.badlogic.gdx.graphics.g2d.SpriteBatch;
import com.badlogic.gdx.math.MathUtils;
import com.badlogic.gdx.math.Rectangle;
import com.badlogic.gdx.utils.Array;
import com.badlogic.gdx.utils.TimeUtils;
import sun.text.resources.cldr.ext.FormatData_xog;

import java.util.Iterator;

import static com.badlogic.gdx.utils.TimeUtils.millis;

public class GameLevelOneEnemy {

    public Array<Enemy> enemies;
    public Array<Enemy> enemiesTwo;
    public Array<BulletEnemy> bulletEnemies;
    private boolean enemyMovementPositive=true; //Enemy movement towards left
    private boolean enemyMovementNegative=false;  //Enemy movement towards right
    private int counter=0; // This counter is used to resolve a bug in movement of enemies

    private BulletEnemy bulletEnemy;
    private long lastTime;

    // variables used to shoot after half second for second group of enemy
    private long firstEnemyShoot;
    private long secondEnemyShoot;
    private long thirdEnemyShoot;


    // Which kind of enemy group is being displayed
    public boolean firstEnemies=true;
    public boolean secondEnemies=false;


    // Following variables are used to know the direction of second group of enemies
    public boolean firstleft=false;
    public boolean secondleft=false;
    public boolean thirdleft=false;

    private Sprite ship;

    public GameLevelOneEnemy(Sprite ship){
        this.ship=ship;
        create();
    }

    /**
     *  All the enemies objects are generated here and their Array too
     */
    public void create(){

       //>
        //> Uploading of first couple of enemies
        //>
        enemies=new Array<Enemy>();
        enemies.add(new Enemy( Gdx.graphics.getWidth()/6, 10,7,"Spaceship_01_RED.png",80,90));
        enemies.add(new Enemy(  Gdx.graphics.getWidth()/6+80 , 10,7,"Spaceship_01_RED.png",80,90));
        enemies.add(new Enemy( Gdx.graphics.getWidth()/6+(80*2) , 10,7,"Spaceship_01_RED.png",80,90));
        enemies.add(new Enemy( Gdx.graphics.getWidth()/6+(80*3) , 10,7,"Spaceship_01_RED.png",80,90));
        enemies.add(new Enemy(Gdx.graphics.getWidth()/6+(80*4) , 10,7,"Spaceship_01_RED.png",80,90));

        //>
        //> Uploading of second couple of enemies
        //>
        enemiesTwo=new Array<Enemy>();
        enemiesTwo.add(new Enemy(0,15,15,"Spaceship_03_NAVY BLUE.png",80,90));
        enemiesTwo.add(new Enemy(Gdx.graphics.getWidth()/3,15,15,"Spaceship_03_NAVY BLUE.png",80,90));
        enemiesTwo.add(new Enemy(Gdx.graphics.getWidth()/2+Gdx.graphics.getWidth()/6,10,15,"Spaceship_03_NAVY BLUE.png",80,90));


        //>
        //> All the bullets generated by enemies are added to this Array
        //>
        bulletEnemies=new Array<BulletEnemy>();

    }

    /**
     *  Update the movement of the enemies
     * @param batch
     */

    public void update(SpriteBatch batch){


        //>
        //> Loop of 5 enemies which move together, enemies stop moving vertically after reaching their stop value
        //>
        if (firstEnemies){
        for(Enemy enemy: enemies) {
            enemy.updateDown(batch);
            if ((enemy.getEnemyY()>Gdx.graphics.getHeight()/2)!=true)
                enemy.isStopVerticalMovementDown(true);

            if (enemyMovementPositive ) {
                enemy.setEnemyX(enemy.getEnemyX()+1);
                if(enemy.getEnemyX() + enemy.getEnemyWidth() >= Gdx.graphics.getWidth())
                {
                    enemyMovementNegative=true;
                    enemyMovementPositive=false;
                }
            } else if (enemyMovementNegative ){
                enemy.setEnemyX(enemy.getEnemyX()-1);

                if(enemy.getEnemyX() <= 0 || counter>0){
                    counter++;
                    if (counter==5){

            enemyMovementPositive=true;
            enemyMovementNegative=false;
            counter=0;        }        }
            }


        }

             //>
            //> Ones all the first group of enemies are destroyed then second group of enemies are generated
            //>
        if (enemies.size==0){
           secondEnemies=true;
           firstEnemies=false;
        }




        }


        //>
        //> Enemies of second group
        //>
        if (secondEnemies){
            for(Enemy enemy: enemiesTwo)
            {
                enemy.updateDown(batch);


                if (enemy.getEnemyX() >= 0 && enemy.getEnemyX() + enemy.getEnemyWidth() <= Gdx.graphics.getWidth() / 3) {
                    if (firstleft != true) {
                        if (enemy.getEnemyX()+enemy.getEnemyWidth()!=Gdx.graphics.getWidth() / 3)
                        enemy.setEnemyX(enemy.getEnemyX() + 1);
                        if (enemy.getEnemyX() + enemy.getEnemyWidth() == Gdx.graphics.getWidth() / 3) {
                            firstleft = true;
                        }
                    } else if (firstleft) {
                        enemy.setEnemyX(enemy.getEnemyX() - 1);

                        if (enemy.getEnemyX() <= 0) {
                            firstleft = false;
                        }
                    }

                }

                // Second enemy of second group of enemy
                if (enemy.getEnemyX() >= Gdx.graphics.getWidth() / 3
                        && enemy.getEnemyX() < Gdx.graphics.getWidth() - Gdx.graphics.getWidth() / 3) {

                    if (secondleft != true) {
                        enemy.setEnemyX(enemy.getEnemyX() + 1);
                        if (enemy.getEnemyX() + enemy.getEnemyWidth() >= Gdx.graphics.getWidth() - Gdx.graphics.getWidth() / 3) {
                            secondleft = true;
                        }
                    } else if (secondleft) {
                        enemy.setEnemyX(enemy.getEnemyX() - 1);

                        if (enemy.getEnemyX() <= Gdx.graphics.getWidth() / 3) {
                            secondleft = false;
                        }
                    }

                }


                if (enemy.getEnemyX() >= Gdx.graphics.getWidth() - Gdx.graphics.getWidth() / 3 &&
                        enemy.getEnemyX() <= Gdx.graphics.getWidth()) {
                    if (thirdleft != true) {
                        enemy.setEnemyX(enemy.getEnemyX() + 1);
                        if (enemy.getEnemyX() + enemy.getEnemyWidth() >= Gdx.graphics.getWidth()) {
                            thirdleft = true;
                        }
                    } else if (thirdleft) {
                        enemy.setEnemyX(enemy.getEnemyX() - 1);

                        if (enemy.getEnemyX() <= Gdx.graphics.getWidth() - Gdx.graphics.getWidth() / 3) {
                            thirdleft = false;
                        }
                    }
                }


                if(enemy.getEnemyY()<=Gdx.graphics.getHeight()/2) {
                    enemy.isStopVerticalMovementDown(true);
                }
                //>
                //> Each enemy in second group has its own moving condition and enemyNumber inside the loop tells
                //> Which one should be implemented for that enemy
                //>
            }


        }


        //>
        //> Loop of enemy bullets
        //>
        for (BulletEnemy bulletEnemy: bulletEnemies) {
            bulletEnemy.render(batch);


    }}

    /**
     * This medhod generate the bullets for all the enemies by checking which
     * group of enemies is being displayed
     */


    public void generateEnemyBullet() {

        //>
        //>  Bullet of first group of enemy
        //>
        if (firstEnemies)
            for (Enemy enemy : enemies){
                if(MathUtils.random(0,90)==1)
                spawnBullet(enemy.getEnemyX() + enemy.getEnemyWidth() / 2 + 10, enemy.getEnemyY() + enemy.getEnemyHeight() / 8);
            }

        //>
        //> Bullet of second group of enemy
        //>
        if (secondEnemies ){
            counter=0;// used to define uniquely a enemy

            for (Enemy enemy:enemiesTwo){

                // Enemy of this group generates bullet every half second
                if(ship.getX()>=0 && ship.getX()<=Gdx.graphics.getWidth()/3 && counter==0) {
                    if (TimeUtils.millis()-firstEnemyShoot>500) {
                        spawnBullet(enemy.getEnemyX() + enemy.getEnemyWidth() / 2, enemy.getEnemyY() + enemy.getEnemyHeight() / 8);
                        firstEnemyShoot=TimeUtils.millis();
                    }

                }


                else if (ship.getX()>=Gdx.graphics.getWidth()/3 && ship.getX()<=Gdx.graphics.getWidth()/2+Gdx.graphics.getWidth()/6 && counter==1) {
                    if (TimeUtils.millis()-secondEnemyShoot>500) {
                        spawnBullet(enemy.getEnemyX() + enemy.getEnemyWidth() / 2, enemy.getEnemyY() + enemy.getEnemyHeight() / 8);
                        secondEnemyShoot=TimeUtils.millis();
                    }
                }


                else if (ship.getX()>=Gdx.graphics.getWidth()/2+Gdx.graphics.getWidth()/6 && ship.getX()<Gdx.graphics.getWidth() && counter==2){
                    if (TimeUtils.millis()-thirdEnemyShoot>500) {
                        spawnBullet(enemy.getEnemyX() + enemy.getEnemyWidth() / 2, enemy.getEnemyY() + enemy.getEnemyHeight() / 8);
                        thirdEnemyShoot=TimeUtils.millis();
                    }
                }

                   counter++;


            }}
        }

    /**
     * It is used for generating new bullets
     *
     */

    public void spawnBullet(float x,float y) {
        bulletEnemy = new BulletEnemy((int)x,(int)y,"laser.png");
        bulletEnemies.add(bulletEnemy);
    }


}
